"""Graph export utilities for vessel graphs.

Exports NetworkX vessel graphs to standard formats:
- GraphML: via networkx.write_graphml (XML-based graph format)
- SWC: neuron morphology format (7-column text: id type x y z radius parent)

Uses established libraries (networkx for GraphML) rather than custom
implementations. See CLAUDE.md Critical Rule #3.
"""

from __future__ import annotations

from pathlib import Path

import networkx as nx


def export_graphml(graph: nx.Graph, path: Path) -> None:
    """Export vessel graph to GraphML format.

    Uses networkx.write_graphml which handles all node/edge attributes
    automatically. GraphML is an XML-based format widely supported by
    graph visualization tools (Gephi, Cytoscape, yEd).

    Parameters
    ----------
    graph:
        NetworkX graph with node/edge attributes.
    path:
        Output file path (.graphml).
    """
    path = Path(path)
    nx.write_graphml(graph, str(path))


def export_swc(graph: nx.Graph, path: Path) -> None:
    """Export vessel graph to SWC format.

    SWC is a standard neuronal morphology format with 7 columns:
    id  type  x  y  z  radius  parent_id

    Type codes: 0=undefined, 1=soma, 2=axon, 3=dendrite, 5=fork, 6=end.
    We use: 5=junction, 6=endpoint, 3=intermediate.

    For tree structures, parent_id links to the upstream node.
    For graphs with cycles, a spanning tree is computed first.

    Parameters
    ----------
    graph:
        NetworkX graph with node attributes (z, y, x, radius, node_type).
    path:
        Output file path (.swc).
    """
    path = Path(path)

    if graph.number_of_nodes() == 0:
        path.write_text("# SWC file (empty graph)\n", encoding="utf-8")
        return

    # Convert graph to spanning tree for SWC (which requires tree structure)
    if nx.is_connected(graph):
        tree = nx.minimum_spanning_tree(graph)
    else:
        # Handle disconnected components
        tree = nx.Graph()
        for component in nx.connected_components(graph):
            subgraph = graph.subgraph(component)
            tree = nx.compose(tree, nx.minimum_spanning_tree(subgraph))

    # Root at first endpoint (or arbitrary node)
    nodes = list(tree.nodes)
    root = nodes[0]
    for n, d in tree.nodes(data=True):
        if d.get("node_type") == "endpoint":
            root = n
            break

    # BFS traversal for parent assignment
    bfs_order = list(nx.bfs_edges(tree, source=root))
    parent_map: dict[object, object] = {root: -1}
    for parent, child in bfs_order:
        parent_map[child] = parent

    # Assign sequential IDs
    all_nodes = [root] + [child for _, child in bfs_order]
    node_to_id: dict[object, int] = {n: i + 1 for i, n in enumerate(all_nodes)}

    # SWC type codes
    type_map = {"junction": 5, "endpoint": 6, "intermediate": 3}

    lines = ["# SWC file generated by minivess vessel graph pipeline"]
    lines.append("# id type x y z radius parent")

    for node in all_nodes:
        data = graph.nodes[node]
        swc_id = node_to_id[node]
        node_type_str = data.get("node_type", "intermediate")
        swc_type = type_map.get(node_type_str, 0)
        x = data.get("x", 0)
        y = data.get("y", 0)
        z = data.get("z", 0)
        radius = data.get("radius", 0.0)
        parent_node = parent_map.get(node, -1)
        parent_id = node_to_id.get(parent_node, -1) if parent_node != -1 else -1
        lines.append(f"{swc_id} {swc_type} {x} {y} {z} {radius:.4f} {parent_id}")

    path.write_text("\n".join(lines) + "\n", encoding="utf-8")
